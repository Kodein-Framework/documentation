<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kodein-DB :: Kodein-Framework Documentation</title>
    <link rel="canonical" href="https://kodein.org/documentation/kodein-db/dev/core.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
      <nav class="navbar">
        <div class="navbar-brand">
          <a class="navbar-item" href="https://kodein.org/documentation">
            <div class="navbar-brand-logo"></div>
            <div style="font-weight: 700;">KODEIN</div>
            <div style="font-weight: 300; opacity:0.8;">Framework</div>
          </a>
        </div>
        <div id="topbar-nav" class="navbar-menu">
          <div class="navbar-end">
            <a class="navbar-item" href="https://kodein.net" target="_blank">
              <div style="font-weight: 300;opacity:0.8;padding-right: 0.5rem">by</div>
              <div style="font-weight: 700;">KODEIN</div>
              <div style="font-weight: 300;opacity:0.8;">Koders</div>
            </a>
          </div>
        </div>
    </nav>
</header>
<div class="body">
<div class="nav-container" data-component="kodein-db" data-version="dev">
  <div class="navbar-bottom-line-linear"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="core.html">Kodein-DB</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="core.html">Home</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Kodein-DB</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Kodein-DB</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="core.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Kodein-DI</span>
      <ul class="versions">
        <li class="version">
          <a href="../../kodein-di/7.1/index.html">7.1 dev</a>
        </li>
        <li class="version is-latest">
          <a href="../../kodein-di/7.0/index.html">7.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Kodein-Framework</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../kodein-framework/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
  <div class="navbar-bottom-line-gradient"></div>
  <div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../kodein-framework/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="core.html">Kodein-DB</a></li>
    <li><a href="core.html">Home</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/Kodein-Framework/Kodein-DB/edit/antora-master/doc/modules/ROOT/pages/core.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Kodein-DB</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#_description">Description</a></li>
<li><a href="#_example">Example</a></li>
</ul>
</li>
<li><a href="#_install">Install</a>
<ul class="sectlevel2">
<li><a href="#_jvm">JVM</a></li>
<li><a href="#_multiplatform_andor_native_gradle">Multiplatform and/or Native (Gradle)</a></li>
</ul>
</li>
<li><a href="#immutability">Immutability requirement</a></li>
<li><a href="#_opening_a_database">Opening a database</a>
<ul class="sectlevel2">
<li><a href="#_open_statement">Open statement</a></li>
<li><a href="#_defining_the_serializer">Defining the serializer</a></li>
</ul>
</li>
<li><a href="#_models">Models</a>
<ul class="sectlevel2">
<li><a href="#_metadata">Metadata</a>
<ul class="sectlevel3">
<li><a href="#_id_and_indexes">ID and Indexes</a></li>
<li><a href="#_with_annotations">With annotations</a></li>
<li><a href="#_with_the_model">With the model</a></li>
<li><a href="#_with_an_extractor">With an extractor</a></li>
<li><a href="#id-index">Using ID as an index</a></li>
</ul>
</li>
<li><a href="#_key_references">Key &amp; References</a></li>
</ul>
</li>
<li><a href="#_operations">Operations</a>
<ul class="sectlevel2">
<li><a href="#_put_delete_get">Put, Delete, Get</a></li>
<li><a href="#_handling_keys">Handling Keys</a>
<ul class="sectlevel3">
<li><a href="#_definition">Definition</a></li>
<li><a href="#_creating_a_key">Creating a Key</a>
<ul class="sectlevel4">
<li><a href="#_from_a_model">From a model</a></li>
<li><a href="#key-from-id">From ID values</a></li>
<li><a href="#_from_a_base64_representation">From a Base64 representation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_iteration">Iteration</a>
<ul class="sectlevel3">
<li><a href="#getting-cursor">Getting a cursor</a></li>
<li><a href="#_using_a_cursor">Using a cursor</a>
<ul class="sectlevel4">
<li><a href="#_as_is">As is</a></li>
<li><a href="#_as_a_sequence">As a sequence</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#polymorphism">Polymorphism</a>
<ul class="sectlevel2">
<li><a href="#_the_problem">The problem</a></li>
<li><a href="#_jvm_only_annotation">JVM only annotation</a></li>
<li><a href="#type-table">Type Table</a></li>
</ul>
</li>
<li><a href="#_consistency">Consistency</a>
<ul class="sectlevel2">
<li><a href="#batch">Batch</a></li>
<li><a href="#snapshot">Snapshot</a></li>
</ul>
</li>
<li><a href="#_being_reactive">Being reactive</a>
<ul class="sectlevel2">
<li><a href="#_listeners_and_subscriptions">Listeners and subscriptions</a>
<ul class="sectlevel3">
<li><a href="#_using_the_dsl">Using the DSL</a></li>
<li><a href="#_using_the_dblistener_interface">Using the <code>DBListener</code> interface</a></li>
</ul>
</li>
<li><a href="#_before_an_operation">Before an operation</a>
<ul class="sectlevel3">
<li><a href="#_simple_check">simple check</a></li>
<li><a href="#_accessing_the_deleted_model">Accessing the deleted model</a></li>
</ul>
</li>
<li><a href="#_after_an_operation">After an operation</a>
<ul class="sectlevel3">
<li><a href="#reaction">simple reaction</a></li>
<li><a href="#_accessing_the_deleted_model_2">Accessing the deleted model</a></li>
</ul>
</li>
<li><a href="#context">Informing listeners</a></li>
<li><a href="#_local_reactions">Local reactions</a>
<ul class="sectlevel3">
<li><a href="#_regular">Regular</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_advanced_usage">Advanced usage</a>
<ul class="sectlevel2">
<li><a href="#_handling_the_cache">Handling the cache</a>
<ul class="sectlevel3">
<li><a href="#_definition_2">Definition</a></li>
<li><a href="#_configuring_at_open">Configuring at open</a></li>
<li><a href="#_model_skip_refresh">Model skip &amp; refresh</a></li>
</ul>
</li>
<li><a href="#_using_primitives">Using primitives</a></li>
<li><a href="#locking-check">Locking checks and reactions</a></li>
<li><a href="#values-and-buffers">Handling Values and Buffers</a></li>
<li><a href="#_fine_graining_deserialization">Fine-graining (de)serialization</a>
<ul class="sectlevel3">
<li><a href="#_writing_your_own_optimised_deserializers">Writing your own optimised (de)serializers</a></li>
</ul>
</li>
<li><a href="#_leveldb_options">LevelDB Options</a></li>
<li><a href="#_embedding_your_logic">Embedding your logic</a>
<ul class="sectlevel3">
<li><a href="#_layered_architecture">Layered architecture</a></li>
<li><a href="#_model_middleware">Model middleware</a></li>
<li><a href="#_data_middleware">Data middleware</a></li>
<li><a href="#_leveldb_middleware">LevelDB middleware</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Multiplatform Kotlin embedded NoSQL database.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_description"><a class="anchor" href="#_description"></a>Description</h3>
<div class="paragraph">
<p>Kodein DB is an embedded NoSQL database that works on JVM, Android, Kotlin/Native and iOS.
It is suited for client or mobile applications.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Under no circumstances should it be used in a server!
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">Kodein-DB allows you to:</div>
<ul>
<li>
<p>Easily store, retrieve and query kotlin objects.</p>
</li>
<li>
<p>Stop carrying about schema definitions.</p>
</li>
<li>
<p>Easily set up a new project.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Kodein-DB is a good choice because it:</div>
<ul>
<li>
<p>proposes a very simple and readable DSL.</p>
</li>
<li>
<p>integrates nicely with Android and iOS.</p>
</li>
<li>
<p>offers very good performances.</p>
</li>
<li>
<p>is just Kotlin!</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_example"><a class="anchor" href="#_example"></a>Example</h3>
<div class="listingblock">
<div class="title">A simple example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db")

db.put(User("John", "Doe"))
db.put(User("Jane", "Doe"))
db.put(User("Someone", "Else"))

val does = db.find&lt;User&gt;().byIndex("lastName", "Doe").models()
println(does.joinToString()) // Jane, John</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_install"><a class="anchor" href="#_install"></a>Install</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Kodein-DB is in beta.</strong></p>
</div>
<div class="paragraph">
<p>Although, we do use Kodein-DB in production, this means we cannot ensure the library&#8217;s correctness and stability.
Therefore, we ask that you first try Kodein-DB in non-critical applications, and report any mis-behaviour you may encounter.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_jvm"><a class="anchor" href="#_jvm"></a>JVM</h3>
<div class="paragraph">
<p>Add the repository:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        maven { url "https://dl.bintray.com/kodein-framework/Kodein-DB" }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kodein-DB will eventually be sync&#8217;d with JCenter, when it exits beta.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    implementation 'org.kodein.db:kodein-db-jvm:0.1.0'
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are developing a library and not an application, use the artifact <code>org.kodein.db:kodein-db-api-jvm:0.1.0</code> instead, which only provides the Kodein-DB API, and not its implementation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, you need to add the serializer you are going to use.
When targetting JVM only, you can use <a href="https://github.com/EsotericSoftware/kryo">Kryo</a>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    implementation 'org.kodein.db:kodein-db-serializer-kryo-jvm:0.1.0'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, if you are targeting a desktop OS, you must add the OS specific leveldb native build dependency:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    implementation 'org.kodein.db:kodein-leveldb-jni-linux:0.1.0' // 'linux' or 'macos'
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are targeting multiple desktop OS, it is OK to add multiple <code>kodein-leveldb-jni-*</code> dependencies.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_multiplatform_andor_native_gradle"><a class="anchor" href="#_multiplatform_andor_native_gradle"></a>Multiplatform and/or Native (Gradle)</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kodein-DB supports the following targets:<br>
      iosArm32, iosArm64, iosX64, linuxX64, macosX64, mingwX64
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kodein-DB uses the new gradle native dependency model, which is experimental in gradle.
You need to enable it in your <code>settings.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">enableFeaturePreview("GRADLE_METADATA")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, in your <code>build.gradle</code> file, add the repository:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        maven { url "https://dl.bintray.com/kodein-framework/Kodein-DB" }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kodein-DB will eventually be sync&#8217;d with JCenter, when it exits beta.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation "org.kodein.db:kodein-db:0.1.0"
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thanks to Gradle Metadata, you don&#8217;t need to add any additional dependency to your targets.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are developing a library and not an application, use the artifact <code>org.kodein.db:kodein-db-api:0.1.0</code> instead, which only provides the Kodein-DB API, and not its implementation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, you need to add the serializer you are going to use.
When targetting Multiplatform, you need to use <a href="https://github.com/Kotlin/kotlinx.serialization">KotlinX Serialization</a>:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation 'org.kodein.db:kodein-db-serializer-kotlinx:0.1.0'
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="immutability"><a class="anchor" href="#immutability"></a>Immutability requirement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kodein-DB works under the assumption that your models (ie. the objects that are going to be managed by the database) are immutable.
This can be seen as paradoxical for a database library: you need to be able to update your data!</p>
</div>
<div class="paragraph">
<p>Kodein-DB is a document based NoSQL library, it works much like a folder drawer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inserting a document is like printing a new document and putting it inside the appropriate drawer at the correct position.</p>
</li>
<li>
<p>Updating a document is like printing the updated document, and putting it inside the drawer, removing the old outdated document.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With this analogy, you can see that the document themselves are immutable: you do not scrible over a document, you print a new version to replace the old one.</p>
</div>
<div class="paragraph">
<p>Kodein-DB works the same way: each of your object model must be immutable, and you should create a new model to update one:</p>
</div>
<div class="listingblock">
<div class="title">A simple example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val john = db[johnKey] ?: error("No John!")
db.put(john.copy(phone = "0605040302"))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
There is no way (yet?) in Kotlin to ensure immutability.
           While we cannot force you to use immutable models, we highly recommend that you do.
           Using mutable models will eventually lead to data races, and very hard to find bugs.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opening_a_database"><a class="anchor" href="#_opening_a_database"></a>Opening a database</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_open_statement"><a class="anchor" href="#_open_statement"></a>Open statement</h3>
<div class="paragraph">
<p>To open a new database, use <code>DB.factory</code>:</p>
</div>
<div class="listingblock">
<div class="title">Opening a database</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db")</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, Kodein-DB will create the database if it does not exist.
If you want to modify this behaviour, you can use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LevelDB.OpenPolicy.OPEN</code>: fails if the database does not already exist</p>
</li>
<li>
<p><code>LevelDB.OpenPolicy.CREATE</code>: fails if the database already exists</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Opening an existing database</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db", LevelDB.OpenPolicy.OPEN)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_serializer"><a class="anchor" href="#_defining_the_serializer"></a>Defining the serializer</h3>
<div class="paragraph">
<p>If you are targeting JVM only, then Kodein-DB will find the serializer by itself, so you don&#8217;t need to define it.<br>
<strong>However, when targeting Multiplatform, you need to define the KotlinX serializer and the serialized classes manually:</strong></p>
</div>
<div class="listingblock">
<div class="title">Opening an existing database</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db",
    KotlinXSerializer { <i class="conum" data-value="1"></i><b>(1)</b>
        +User.serializer() <i class="conum" data-value="2"></i><b>(2)</b>
        +Address.serializer() <i class="conum" data-value="2"></i><b>(2)</b>
    }
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registers the KotlinX Serializer.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Registers the class and associate serializer.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_models"><a class="anchor" href="#_models"></a>Models</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_metadata"><a class="anchor" href="#_metadata"></a>Metadata</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong><a href="#immutability">Immutability requirement</a></strong>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_id_and_indexes"><a class="anchor" href="#_id_and_indexes"></a>ID and Indexes</h4>
<div class="paragraph">
<p>A model <strong>may</strong> have <strong>one or more</strong> named indexes, to allow you to <em>search and/or order</em> by a specific value.</p>
</div>
<div class="paragraph">
<p>A model <strong>must</strong> have <strong>one</strong> <em>unique</em> ID, which can be of any type.
This ID defines the default ordering of the models inside the collections.
In essence, the ID works exactly like an index, except that it is unnamed.
You can use <code>UUID.randomUUID()</code> if your model does not have a unique value.</p>
</div>
<div class="paragraph">
<p>Indexes and IDs can be composite, which means that they can contain multiple values.
A composite index allows you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Get models ordered by first value, then second, then third, then&#8230;&#8203;</p>
</li>
<li>
<p>Look for all models with the first value, then second, then third, then&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_with_annotations"><a class="anchor" href="#_with_annotations"></a>With annotations</h4>
<div class="paragraph">
<p>When targeting <strong>only the JVM</strong>, you can simply use annotations:</p>
</div>
<div class="listingblock">
<div class="title">A simple model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    @Id val uid: String,
    val firstName: String,
    @Index("lastName") val lastName: String
)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When using <code>@Id</code> or <code>@Index</code>, Kodein-DB converts <code>String</code> values to byte array using the ASCII charset.
         Therefore, only ASCII characters are allowed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using this configuration, when getting all users by index <code>"lastName"</code>, they will be ordered first by <code>lastName</code>, then by <code>uid</code>.
If you want the results to be ordered by <code>lastName</code> then <code>firstName</code> (then <code>uid</code>), you can use a composite index:</p>
</div>
<div class="listingblock">
<div class="title">Same model with composite index</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    @Id val uid: String,
    val firstName: String,
    val lastName: String
) {
    @Index("name") fun nameIndex() = listOf(lastName, firstName)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_the_model"><a class="anchor" href="#_with_the_model"></a>With the model</h4>
<div class="paragraph">
<p>The model itself can define its metadata by implementing either the <code>Metadata</code> or <code>HasMetadata</code> interface:</p>
</div>
<div class="listingblock">
<div class="title">Model <strong>is</strong> metadata</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    override val id: String, <i class="conum" data-value="1"></i><b>(1)</b>
    val firstName: String,
    val lastName: String
) : Metadata {
    override fun indexes() = indexSet("lastName" to listOf(lastName, firstName)) <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>id</code> property override is mandatory</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>indexes</code> function override is optional (no index by default)</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Model <strong>has</strong> metadata</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    val id: String,
    val firstName: String,
    val lastName: String
) : HasMetadata {
    override fun getMetadata(db: ModelDB, vararg options: Options.Write) =
            Metadata(id, "lastName" to listOf(lastName, firstName))
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_an_extractor"><a class="anchor" href="#_with_an_extractor"></a>With an extractor</h4>
<div class="paragraph">
<p>If you don&#8217;t own the models, or if you don&#8217;t want to mark them for Kodein-DB, you can use register a <code>MetadataExtractor</code> when you open the database:</p>
</div>
<div class="listingblock">
<div class="title">Registering a metadata extractor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db",
    MetadataExtractor {
        when (it) {
            is User -&gt; Metadata(it.id, "lastName" to listOf(it.lastName, it.firstName))
            else -&gt; error("Unknown model $it")
        }
    }
)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-index"><a class="anchor" href="#id-index"></a>Using ID as an index</h4>
<div class="paragraph">
<p>If we consider the <code>User</code> model we have just defined, we have defined the ID to be a UUID, meaning that the order in which they will be stored and retrieved is completely random.<br>
Because the ID must be unique, we cannot use the name to be the ID.
However, we can create a composite ID.
Consider this updated model:</p>
</div>
<div class="listingblock">
<div class="title">Model with a composite ID</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    val uid: String,
    val firstName: String,
    val lastName: String
) : Metadata {
    override val id get() = listOf(lastName, firstName, uid)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because <code>uid</code> is unique, the tuple <code>(lastName, firstName, uid)</code> is unique (if only because it contains <code>uid</code>).
Therefore, the <code>id</code> property is always unique, but the order in which the models will be stored are defined first by <code>lastName</code>, then by <code>firstName</code>, then only by <code>id</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
While using a composite ID can be very useful, it makes the <a href="#key-from-id">creation of key from ID values</a> more complex.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_key_references"><a class="anchor" href="#_key_references"></a>Key &amp; References</h3>
<div class="paragraph">
<p>If a model contains another model, it will be serialized into the same <em>document</em>.
If you need to reference another document, then you need to store a <code>Key</code>:</p>
</div>
<div class="listingblock">
<div class="title">A model with a reference to another model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(
    override val id: String,
    val name: Name, <i class="conum" data-value="1"></i><b>(1)</b>
    val address: Key&lt;Address&gt; <i class="conum" data-value="2"></i><b>(2)</b>
) : Metadata {
    override fun indexes() = indexSet("lastName" to listOf(name.last, name.first))
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Will be included as part of this model&#8217;s document.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>References another model with its own document.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operations"><a class="anchor" href="#_operations"></a>Operations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_put_delete_get"><a class="anchor" href="#_put_delete_get"></a>Put, Delete, Get</h3>
<div class="paragraph">
<p>Kodein-DB does not know the difference between Put and Update.
If you put a document that already exists in the database, it will be overwritten (you can, however, manually <a href="#locking-check">check</a> the existence and state of an overwritten model).</p>
</div>
<div class="paragraph">
<p>To put a document inside the database, simply use the <code>put</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Putting a model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val key = db.put(user) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>put</code> method returns the <code>Key</code> that refers to the model.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can as easily delete a document:</p>
</div>
<div class="listingblock">
<div class="title">Deleting a document</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.delete(key)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get a model, simply use the <code>get</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Getting a model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val user = db[key]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_keys"><a class="anchor" href="#_handling_keys"></a>Handling Keys</h3>
<div class="sect3">
<h4 id="_definition"><a class="anchor" href="#_definition"></a>Definition</h4>
<div class="paragraph">
<p>A <code>Key</code> is the unique identifier that identifies a document (and the associated model) inside the database.
It contains the following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The type of the document (which is also the type of the model, unless you&#8217;re using <a href="#polymorphism">polymorphism</a>).</p>
</li>
<li>
<p>The Id of the document.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can think of Kodein-DB as a file cabinet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The document type defines the drawer inside the cabinet.</p>
</li>
<li>
<p>The document ID is the label that defines the document inside the drawer.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
A key is specific to a Kodein-DB instance: a key refers to a model relative to a specific Kodein-DB.
           Do <strong>not</strong> share a Key: the same model with the same ID may give 2 different keys on two different databases.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_key"><a class="anchor" href="#_creating_a_key"></a>Creating a Key</h4>
<div class="sect4">
<h5 id="_from_a_model"><a class="anchor" href="#_from_a_model"></a>From a model</h5>
<div class="paragraph">
<p>You can always ask Kodein-DB to provide you with the key of a specific model:</p>
</div>
<div class="listingblock">
<div class="title">Creating a key</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val key = db.newKey(user)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
You can create a key from any model, whether it exists in database or not.
         Using <code>newKeyFrom</code> does <strong>not</strong> ensure you that the model exists in database, nor does it put it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="key-from-id"><a class="anchor" href="#key-from-id"></a>From ID values</h5>
<div class="paragraph">
<p>You can easily create a key from its ID value(s):</p>
</div>
<div class="listingblock">
<div class="title">Creating a key</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val key = db.newKey&lt;User&gt;("01234567-89ab-cdef-0123-456789abcdef")</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are using <a href="#id-index">composite IDs</a>, you need to provide all values of the ID.<br>
In the case of the earlier example, you would need to create the key as such:</p>
</div>
<div class="listingblock">
<div class="title">Creating a key with a composite ID</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val key = db.newKey&lt;User&gt;("Doe", "John", "01234567-89ab-cdef-0123-456789abcdef")</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_from_a_base64_representation"><a class="anchor" href="#_from_a_base64_representation"></a>From a Base64 representation</h5>
<div class="paragraph">
<p>Once you have a <code>Key</code> (either from <code>put</code> or <code>newKey</code>), you can serialize it to Base64:</p>
</div>
<div class="listingblock">
<div class="title">serializing a key to Base64</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val b64 = key.toBase64()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can re-create a key from a Base64 string:</p>
</div>
<div class="listingblock">
<div class="title">deserializing a key from Base64</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val key = db.newKeyFromB64(b64)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Even when serialized in Base64, a Key is only valid on the Kodein-DB that created it.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iteration"><a class="anchor" href="#_iteration"></a>Iteration</h3>
<div class="sect3">
<h4 id="getting-cursor"><a class="anchor" href="#getting-cursor"></a>Getting a cursor</h4>
<div class="paragraph">
<p>To iterate over a collection or a subset of a collection, you need to create cursor.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Cursors are <code>Closeable</code>! You need to either close them after use, or to call <code>use</code> on them.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can iterate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Over all models of a collection, ordered by ID:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cursor = db.find&lt;User&gt;().all()</code></pre>
</div>
</div>
</li>
<li>
<p>Over all models of a collection whose composite ID begins with a specific value, ordered by id:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cursor = db.find&lt;User&gt;().byId("Doe")</code></pre>
</div>
</div>
</li>
<li>
<p>Over all models of a collection, ordered by an index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cursor = db.find&lt;User&gt;().byIndex("lastName")</code></pre>
</div>
</div>
</li>
<li>
<p>Over all models of a collection with the specific index (composite or not) value, ordered by that index:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cursor = db.find&lt;User&gt;().byIndex("lastName", "Doe")</code></pre>
</div>
</div>
</li>
<li>
<p>Over all models of the database:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cursor = db.findAll()</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When using <code>findAll()</code> on multiplatform projects, you <strong>must</strong> define a <a href="#type-table">type table</a> that defines all model classes!
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Cursors are working on a <a href="#snapshot">snapshot</a> of the database.
      This means that once an iterator is created, subsequent writes to the database won&#8217;t be reflected in the result of the iteration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_cursor"><a class="anchor" href="#_using_a_cursor"></a>Using a cursor</h4>
<div class="sect4">
<h5 id="_as_is"><a class="anchor" href="#_as_is"></a>As is</h5>
<div class="paragraph">
<p>By default, a cursor points to the first value of the matching query.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can get the key and model with <code>key()</code> and <code>model()</code>.</p>
</li>
<li>
<p>You can move the cursor one item with <code>next()</code> and <code>previous()</code>, or directly to the start or end of the matching items with <code>seekToFirst</code> or <code>seekToLast</code>.<br></p>
</li>
<li>
<p>Each time the cursor moves, you need to check whether it is still valid with <code>isValid()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Iterating with a cursor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.find&lt;User&gt;().byIndex("lastName", "Doe").use { cursor -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    while (cursor.isValid()) {
        val model = cursor.model()
        println(model)
        cursor.next()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>use</code> ensures to close the cursor when iteration ends.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_as_a_sequence"><a class="anchor" href="#_as_a_sequence"></a>As a sequence</h5>
<div class="paragraph">
<p>You can easily transform a <code>Cursor</code> to a <code>Sequence</code>.
Note that when you do, the cursor will be automatically closed when the sequence ends.</p>
</div>
<div class="paragraph">
<p>You can use either <code>models()</code> that creates a squence of models, or <code>entries</code>, that create a sequence of model and key pairs.</p>
</div>
<div class="listingblock">
<div class="title">Iterating with a sequence</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.find&lt;User&gt;().byIndex("lastName", "Doe").models().forEach {
    println(it)
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The sequence will only close when the last item has been collected!</p>
</div>
<div class="paragraph">
<p>The following code will <strong>not</strong> close the associated cursor and create a <strong>resource leak</strong>!</p>
</div>
<div class="listingblock">
<div class="title">Creating a cursor leak</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val first3 = db.find&lt;User&gt;().all()
    .models()
    .take(3) <i class="conum" data-value="1"></i><b>(1)</b>
    .toList()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because we take only the first 3 items, the last item of the cursor is never collected.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The correct way to do this is as such:</p>
</div>
<div class="listingblock">
<div class="title">Getting the first 3 items without resource leak:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val first3 = db.find&lt;User&gt;().all().use { <i class="conum" data-value="1"></i><b>(1)</b>
    it.models()
        .take(3)
        .toList()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>use</code> ensures to close the cursor when iteration ends.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="polymorphism"><a class="anchor" href="#polymorphism"></a>Polymorphism</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_problem"><a class="anchor" href="#_the_problem"></a>The problem</h3>
<div class="paragraph">
<p>By default, Kodein-DB inserts each model in the document collection that corresponds to its real type.</p>
</div>
<div class="paragraph">
<p>Considering the following insertions:</p>
</div>
<div class="listingblock">
<div class="title">Multiple insertions</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">open class Person(@Id val name: String)
class Child(name: String, val parents: List&lt;Key&lt;Person&gt;&gt;): Person(name)

val janeKey = db.put(Person("Jane"))
val johnKey = db.put(Person("John"))

val parents = listOf(janeKey, johnKey)
db.put(Child("Jill", parents))
db.put(Person("Jack", parents))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the preceding code, there will be two different collections, one <code>Person</code>, one <code>Adult</code>, meaning if you were to look for all <code>Person</code> models, you would only get Jane &amp; John.</p>
</div>
<div class="paragraph">
<p>Children are person too (even when they keep asking you when&#8217;s the end of this documentation&#8230;&#8203;) so, you probably want to put every <code>Child</code> model into the <code>Person</code> collection.
To do that, you need to enable polymorphism: the fact that a collection can hold multiple types of models.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jvm_only_annotation"><a class="anchor" href="#_jvm_only_annotation"></a>JVM only annotation</h3>
<div class="paragraph">
<p>The simpler way to define a polymorphic document is to use the <code>@Polymorphic</code> annotation.
However, as usual for annotations, <strong>it only works for the JVM</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Children are Persons</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Polymorphic(Person::class) <i class="conum" data-value="1"></i><b>(1)</b>
class Child(name: String, val parents: List&lt;Key&lt;Person&gt;&gt;): Person(name)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>@Polymorphic</code> annotation instructs Kodein-DB to put <code>Child</code> models into the <code>Person</code> collection.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="type-table"><a class="anchor" href="#type-table"></a>Type Table</h3>
<div class="paragraph">
<p>In Kodein-DB, the Type Table is responsible for defining which model type belongs to which collection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using a Type Table is compatible with multiplatform!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can define a <code>TypeTable</code> when opening the database:</p>
</div>
<div class="listingblock">
<div class="title">Defining a Type Table</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open("path/to/db",
    TypeTable {
        root&lt;Person&gt;() <i class="conum" data-value="1"></i><b>(1)</b>
            .sub&lt;Child&gt;() <i class="conum" data-value="2"></i><b>(2)</b>
    }
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines the root collection <code>Person</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines that all <code>Child</code> models will be put in the <code>Person</code> collection.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_consistency"><a class="anchor" href="#_consistency"></a>Consistency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="batch"><a class="anchor" href="#batch"></a>Batch</h3>
<div class="paragraph">
<p>A batch enables you to apply multiple write operations at once.
With a batch, you can ensure that neither a <a href="#getting-cursor">cursor</a> nor a <a href="#snapshot">snapshot</a> can reflect part of the operations of a batch.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Batches are <code>Closeable</code>! You need to either close them after use, or to call <code>use</code> on them.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Using a batch</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.newBatch().use {
    it.delete(oldAddress)
    val addressKey = it.put(newAddress)
    it.put(user.copy(address = addressKey))
    it.write() <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No modification will be applied to the database until <code>write()</code> is called.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If <code>write()</code> is not conditional before closing the batch, you can use <code>execBatch</code> that combines <code>use()</code> and <code>write()</code>:</p>
</div>
<div class="listingblock">
<div class="title">Using and writing a batch</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.execBatch {
    delete(oldAddress)
    val addressKey = put(newAddress)
    put(user.copy(address = addressKey))
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="snapshot"><a class="anchor" href="#snapshot"></a>Snapshot</h3>
<div class="paragraph">
<p>A snapshot is a <em>read-only</em> version of the database frozen at the time of creation.
Write operations that happen after the creation of a snapshot are not reflected to it.
Snapshot are most of the times used in conjunction with <a href="#batch">batches</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Snapshots are <code>Closeable</code>! You need to either close them after use, or to call <code>use</code> on them.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Using a snapshot</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val (user, address) = db.newSnapshot().use {
    val user = it[userKey]
    val address = it[user.address]
    user to address
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_being_reactive"><a class="anchor" href="#_being_reactive"></a>Being reactive</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_listeners_and_subscriptions"><a class="anchor" href="#_listeners_and_subscriptions"></a>Listeners and subscriptions</h3>
<div class="paragraph">
<p>Kodein-DB supports the reactive pattern.
You can use Kodein-DB as a data event hub, so that you can react to the addition or suppression of documents.</p>
</div>
<div class="paragraph">
<p>A listener is responsible for reacting to an operation.<br>
Once you have registered it, you can get a subscription <code>Closeable</code>, which will stop the listener from being called if you <code>close</code> it.</p>
</div>
<div class="sect3">
<h4 id="_using_the_dsl"><a class="anchor" href="#_using_the_dsl"></a>Using the DSL</h4>
<div class="paragraph">
<p>You can easily register a listener using the ad-hoc DSL:</p>
</div>
<div class="listingblock">
<div class="title">DSL listeners</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register { <i class="conum" data-value="1"></i><b>(1)</b>
}
db.onAll().register { <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registers a listener on the <code>User</code> collection.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Registers a global listener to the entire database.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A DSL listener can access its own subscription (this can be useful if you want the listener to cancel its own subscription after reacting to a certain event) in the context of the callbacks:</p>
</div>
<div class="listingblock">
<div class="title">Accessing the subscription</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    didPut { user -&gt;
        if (whatever) this.subscription.close()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_dblistener_interface"><a class="anchor" href="#_using_the_dblistener_interface"></a>Using the <code>DBListener</code> interface</h4>
<div class="paragraph">
<p>You can have one of your classes implement the <code>DBListener</code> interface and then register it:</p>
</div>
<div class="listingblock">
<div class="title">Class listeners</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {}
class GlobalListener : DBListener&lt;Any&gt; {}

val uSub = db.on&lt;User&gt;().register(UserListener()) <i class="conum" data-value="1"></i><b>(1)</b>
val aSub = db.onAll().register(GlobalListener()) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registers a listener on the <code>User</code> collection.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Registers a global listener to the entire database.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A class listener receives its own subscription (this can be useful if you want the listener to cancel its own subscription after reacting to a certain event) just after registration:</p>
</div>
<div class="listingblock">
<div class="title">Receiving the subscription</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {
    lateinit var subscription: Closeable
    override fun setSubscription(subscription: Closeable) {
        this.subscription = subscription
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_before_an_operation"><a class="anchor" href="#_before_an_operation"></a>Before an operation</h3>
<div class="sect3">
<h4 id="_simple_check"><a class="anchor" href="#_simple_check"></a>simple check</h4>
<div class="paragraph">
<p>You can use the event system to act <em>before</em> an operation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Any exception thrown in a <code>will*</code> callback cancels the operation (or batch of operation) and prevents subsequent callbacks to be called.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reacting before an operation can be useful to ensure that the operation satisfies certain prerequisites, or to throw an exception to interrupt the operation if it isn&#8217;t.</p>
</div>
<div class="listingblock">
<div class="title">A DSL check</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    willPut { user -&gt;
        check(user.name.isNotBlank()) { "User firstName and lastName must not be blank" }
    }
    willDelete {
        val pictureCount = db.find&lt;Picture&gt;().byIndex("userKey", key).entries().count()
        check(pictureCount == 0) { "User has pictures, delete them first" }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A class check</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {
    override fun willPut(model: User, typeName: ReadMemory, metadata: Metadata, options: Array&lt;out Options.Write&gt;) {
        check(model.name.isNotBlank()) { "User firstName and lastName must not be blank" }
    }
    override fun willDelete(key: Key&lt;*&gt;, getModel: () -&gt; User?, typeName: ReadMemory, options: Array&lt;out Options.Write&gt;) {
        val pictureCount = db.find&lt;Picture&gt;().byIndex("userKey", key).entries().count()
        check(pictureCount == 0) { "User has pictures, delete them first" }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_the_deleted_model"><a class="anchor" href="#_accessing_the_deleted_model"></a>Accessing the deleted model</h4>
<div class="paragraph">
<p>You may have noticed in the preceding example that the <code>willDelete</code> callback do not access the deleted model.
That&#8217;s because it is not given to the <code>willDelete</code> DSL callback.<br>
Because the deletion of a document uses its key, and not its model, you need to instruct the system to get the document before deleting it.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the DSL, use the <code>willDeleteIt</code> method:</p>
<div class="listingblock">
<div class="title">DSL delete check with model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    willDeleteIt { user -&gt;
        val pictureCount = db.find&lt;Picture&gt;().byIndex("userId", user.id).entries().count()
        check(pictureCount == 0) { "User has pictures, delete them first" }
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Using the class method, call the <code>getModel</code> function argument:</p>
<div class="listingblock">
<div class="title">DSL delete check with model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {
    override fun willDelete(key: Key&lt;*&gt;, getModel: () -&gt; User?, typeName: ReadMemory, options: Array&lt;out Options.Write&gt;) {
        val user = getModel()
        val pictureCount = db.find&lt;Picture&gt;().byIndex("userId", user.id).entries().count()
        check(pictureCount == 0) { "User has pictures, delete them first" }
    }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_after_an_operation"><a class="anchor" href="#_after_an_operation"></a>After an operation</h3>
<div class="sect3">
<h4 id="reaction"><a class="anchor" href="#reaction"></a>simple reaction</h4>
<div class="paragraph">
<p>You can react after an operation, this can be useful:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Locally if you want to keep or a local state (such as a UI) up to date:</p>
</li>
<li>
<p>Globally if you want to keep a global state (such as the database itself) up to date.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any exception thrown from a <code>did*</code> callback will <strong>not</strong> prevent other listeners to be called.
      Kodein-DB ensures that all <code>did*</code> listeners are called when an operation has suceeded.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">A DSL reaction</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    didPut { user -&gt; ui.add(user) }
    didDelete { ui.reload() }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">A class reaction</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {
    override fun didPut(model: User, key: Key&lt;*&gt;, typeName: ReadMemory, metadata: Metadata, size: Int, options: Array&lt;out Options.Write&gt;) {
        ui.add(model)
    }
    override fun didDelete(key: Key&lt;*&gt;, model: User?, typeName: ReadMemory, options: Array&lt;out Options.Write&gt;) {
        ui.reload()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that all arguments of the listener&#8217;s methods are available in the DSL in the <code>this</code> context.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use <code>didDelete</code> to simulate cascading in a global listener:</p>
</div>
<div class="listingblock">
<div class="title">DSL delete reaction with model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    didDelete {
        db.find&lt;Picture&gt;().byIndex("userKey", key).entries().forEach {
            db.delete(it.key)
        }
    }
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_the_deleted_model_2"><a class="anchor" href="#_accessing_the_deleted_model_2"></a>Accessing the deleted model</h4>
<div class="paragraph">
<p>You may have noticed in the preceding example that the <code>didDelete</code> callback do not access the deleted model.
That&#8217;s because it is not given to the <code>didDelete</code> DSL callback, and will probably be null in the <code>didDelete</code> class method.<br>
Because the deletion of a document uses its key, and not its model, you need to instruct the system to get the document before deleting it.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the DSL, simply use the <code>didDeleteIt</code> method:</p>
<div class="listingblock">
<div class="title">DSL delete reaction with model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    didDeleteIt { user -&gt; ui.remove(user) }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Using the class method, call the <code>getModel</code> function argument in <code>willDelete</code>:</p>
<div class="listingblock">
<div class="title">DSL delete reaction with model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class UserListener : DBListener&lt;User&gt; {
    override fun willDelete(key: Key&lt;*&gt;, getModel: () -&gt; User?, typeName: ReadMemory, options: Array&lt;out Options.Write&gt;) {
        getModel()
    }
    override fun didDelete(key: Key&lt;*&gt;, model: User?, typeName: ReadMemory, options: Array&lt;out Options.Write&gt;) {
        ui.remove(model)
    }
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>Informing listeners</h3>
<div class="paragraph">
<p>Sometimes, you need to pass some context to the listener(s).
Things like "Where is the operation coming from?" or "Why is this operation happening?".
In short, you may need to inform your listeners about <em>context</em>.</p>
</div>
<div class="paragraph">
<p>For example, you may want to know if you are creating a new <code>User</code>, or updating one.</p>
</div>
<div class="paragraph">
<p>Doing so is easy.
First, create a class that will hold the context and have it implement <code>Options.Write</code>:</p>
</div>
<div class="listingblock">
<div class="title">A context class</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">enum class UserContext : Options.Write {
    NEW, UPDATE
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, recover it from your listener:</p>
</div>
<div class="listingblock">
<div class="title">Reading context in a listener</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.on&lt;User&gt;().register {
    didPut {
        val context = options.filterIsInstance&lt;UserContext&gt;().firstOrNull()
        when (context) {
            UserContext.NEW -&gt; { /* insertion */ }
            UserContext.UPDATE -&gt; { /* update */ }
            null -&gt; { /* unknown */ }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, don&#8217;t forget to add the context option when you perform the operation:</p>
</div>
<div class="listingblock">
<div class="title">Adding context to a put.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.put(newUser, UserContext.NEW)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_local_reactions"><a class="anchor" href="#_local_reactions"></a>Local reactions</h3>
<div class="paragraph">
<p>You may need to attach a callback to a specific operation or batch of operation.
For that, Kodein-DB provides the <code>Anticipate</code> and <code>React</code> options.</p>
</div>
<div class="sect3">
<h4 id="_regular"><a class="anchor" href="#_regular"></a>Regular</h4>
<div class="paragraph">
<p>You can easilly add a check that will run before an operation is performed (this is especially usefull for a batch):</p>
</div>
<div class="listingblock">
<div class="title">Adding context to a put.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.put(newUser,
        Anticipate { println("Will put a user!") },
        React { println("Did put a user!") }
)

db.newBatch().use { batch -&gt;
    batch.addOptions(
            Anticipate { println("Will write batch!") },
            React { println("Did write batch!") }
    )
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_usage"><a class="anchor" href="#_advanced_usage"></a>Advanced usage</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_handling_the_cache"><a class="anchor" href="#_handling_the_cache"></a>Handling the cache</h3>
<div class="sect3">
<h4 id="_definition_2"><a class="anchor" href="#_definition_2"></a>Definition</h4>
<div class="paragraph">
<p>Kodein-DB provides an object-cache that reflects the data that is serialized inside the database.<br>
When querying for a data (either by <code>DB.get</code> or <code>DB.find</code>) if the needed data is already in the cache, then instead of de-serializing it, Kodein-DB immediately returns the cached value.</p>
</div>
<div class="paragraph">
<p>Kodein-DB updates the cache:
- at every <code>put</code> (both the database and the cache save the model)
- at every <code>get</code> or <code>find</code> (if the model is not in the cache, then the cache saves the model to prevent any future deserialization).</p>
</div>
<div class="paragraph">
<p>This enhances performances as deserialization is one of the most expensive operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_at_open"><a class="anchor" href="#_configuring_at_open"></a>Configuring at open</h4>
<div class="paragraph">
<p>Kodein-DB allows you to pass multiple configuration values that modify cache behaviour when opening a database.</p>
</div>
<div class="paragraph">
<p>You may want to define the maximum size of the cache:</p>
</div>
<div class="listingblock">
<div class="title">Opening a database:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open(
    "path/to/db",
    ModelCache.MaxSize(Runtime.getRuntime().totalMemory() / 8) <i class="conum" data-value="1"></i><b>(1)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Default on JVM &amp; Android.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The cache also works on snapshots (remember: Kodein-DB automatically uses a snapshot when using a cursor or a sequence).
When you create a snapshot (or a cursor), it uses the same cache.<br>
However, if you mutate the database while holding a snapshot, than the cache must be copied in order for the snapshot to use a cache that only reflects the database when it was created.
This is a rare case (if you correctly close your cursors / snapshots) and only object references are copied, so the process itself is as optimised as can be.
However, you may need to handle the size of these snapshot-specific copies.</p>
</div>
<div class="listingblock">
<div class="title">Opening a database:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val cacheSize = Runtime.getRuntime().totalMemory() / 8
val db = DB.open(
    "path/to/db",
    ModelCache.MaxSize(cacheSize),
    ModelCache.CopyMaxSize(cacheSize / 4) <i class="conum" data-value="1"></i><b>(1)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Default on JVM &amp; Android.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, if you don&#8217;t want any caching, you can simply disable the cache:</p>
</div>
<div class="listingblock">
<div class="title">Disabling the cache:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open(
    "path/to/db",
    ModelCache.Disable
)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_model_skip_refresh"><a class="anchor" href="#_model_skip_refresh"></a>Model skip &amp; refresh</h4>
<div class="paragraph">
<p>There are times when you may want to bypass the cache for a specific operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you <strong>put</strong> a model you won&#8217;t need in the future:</p>
<div class="listingblock">
<div class="title">Bypassing the cache:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.put(model, ModelCache.Skip)</code></pre>
</div>
</div>
</li>
<li>
<p>When you <strong>get</strong> a model you won&#8217;t query again in the future:</p>
<div class="listingblock">
<div class="title">Bypassing the cache:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val m1 = db.get(model, ModelCache.Skip) <i class="conum" data-value="1"></i><b>(1)</b>
val m2 = db.get(model, ModelCache.Refresh) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Skips the cache (and removes any cached value).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Forces the cache to refresh from the serialized model in DB.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_primitives"><a class="anchor" href="#_using_primitives"></a>Using primitives</h3>
<div class="paragraph">
<p>If you want a simple key-value collection, Kodein-DB provides optimized primitives for <code>Int</code>, <code>Long</code>, <code>Double</code> and <code>String</code>.
This can be useful for configuration-like values.</p>
</div>
<div class="listingblock">
<div class="title">Using a primitive:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.put(Primitive(id = "name", value = "John Doe"))
/*...*/
val name = db[db.newKey&lt;StringPrimitive&gt;("name")]?.value</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking-check"><a class="anchor" href="#locking-check"></a>Locking checks and reactions</h3>
<div class="paragraph">
<p>Both <code>Anticipate</code> and <code>React</code> can allow you to run the provided callback in a locked database (through the <code>needsLock</code> optional parameter).
Using this means that the database will be completely write-locked for the duration of the callback execution.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This can be very useful for things like transactions but can lead to dead locks and/or performance degradations.
Be extra-careful when using this feature !
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="values-and-buffers"><a class="anchor" href="#values-and-buffers"></a>Handling Values and Buffers</h3>
<div class="paragraph">
<p>Kodein-DB uses <a href="https://github.com/Kodein-Framework/Kodein-Memory">Kodein-Memory</a> for its low-level bit-level memory manipulation.
Every memory that LevelDB (the low-level data store) handles is actually a <code>KBuffer</code>.</p>
</div>
<div class="paragraph">
<p>Kodein-DB uses the concept of <code>Value</code> to transform IDs and indexes to memory.
Every Kodein-DB API that takes an <code>Any</code> parameter for the ID or an index value can be slightly optimized by giving it the <code>Value</code> representation.
The optimization becomes more important for composite values.</p>
</div>
<div class="listingblock">
<div class="title">Using Values:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">db.find&lt;Address&gt;().byId(Value.ofAll(Value.ofAscii("France"), Value.ofInt(75000)))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fine_graining_deserialization"><a class="anchor" href="#_fine_graining_deserialization"></a>Fine-graining (de)serialization</h3>
<div class="sect3">
<h4 id="_writing_your_own_optimised_deserializers"><a class="anchor" href="#_writing_your_own_optimised_deserializers"></a>Writing your own optimised (de)serializers</h4>
<div class="paragraph">
<p>If you want to handle a specific class serialization by yourself you can write your own serializer with the <code>org.kodein.db.model.orm.Serializer</code> interface:</p>
</div>
<div class="listingblock">
<div class="title">Using specific serializer:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class User(@Id val id: String, val name: String) {
    object S : Serializer&lt;User&gt; {
        override fun serialize(model: User, output: Writeable, vararg options: Options.Write) { <i class="conum" data-value="1"></i><b>(1)</b>
            output.putSizeAndString(model.id, Charset.ASCII)
            output.putSizeAndString(model.name, Charset.UTF8)
        }
        override fun deserialize(type: KClass&lt;out User&gt;, transientId: ReadMemory, input: ReadBuffer, vararg options: Options.Read): User { <i class="conum" data-value="1"></i><b>(1)</b>
            val id = input.readSizeAndString(Charset.UTF8)
            val name = input.readSizeAndString(Charset.UTF8)
            return User(id, name)
        }
    }
}
val db = DB.open("path/to/db",
        +User.S <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You can use <a href="#context">context</a> or specific options with the array of <code>Options.Write</code> options.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Don&#8217;t forget to <strong>register the listener</strong> when opening the database!</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_leveldb_options"><a class="anchor" href="#_leveldb_options"></a>LevelDB Options</h3>
<div class="paragraph">
<p>As Kodein-DB uses LevelDB underneath, you can pass various LevelDB specific configuration values:</p>
</div>
<div class="listingblock">
<div class="title">Using LevelDB options:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val db = DB.open(
    "path/to/db",
    LevelDBOptions.PrintLogs(true)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Have a look at the <code>org.kodein.db.ldb.LevelDBOptions</code> sealed class for an overview of all available options.</p>
</div>
</div>
<div class="sect2">
<h3 id="_embedding_your_logic"><a class="anchor" href="#_embedding_your_logic"></a>Embedding your logic</h3>
<div class="sect3">
<h4 id="_layered_architecture"><a class="anchor" href="#_layered_architecture"></a>Layered architecture</h4>
<div class="paragraph">
<p>Kodein-DB uses a layered architecture: each layer transforms an operation into a "simpler" operation that can be then handled by a lower layer.</p>
</div>
<div class="paragraph">
<p>Here are the layers, from top to bottom:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>API</strong>: creates a nice API that can be used in a MPP application. This is the API you are using.</p>
</li>
<li>
<p><strong>Cache</strong>: Intercepts queries that would create a model already in cache and return that model instead.</p>
</li>
<li>
<p><strong>Model</strong>: Transforms a model into a document (a.k.a. serialized bytes and associated metadata) and vice versa.</p>
</li>
<li>
<p><strong>Data</strong>: Handles the document, its metadata and its indexes, transforming it to LevelDB entries.</p>
</li>
<li>
<p><strong>LevelDB</strong>: Stores and retrieves entries.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kodein-DB allows you to add your own layers in this stack.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Most layer methods receive an array of options, which means that a middleware can recieve context or configuration the same way <a href="#context">a listener receives it</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_model_middleware"><a class="anchor" href="#_model_middleware"></a>Model middleware</h4>
<div class="paragraph">
<p>A model middleware sits between the <strong>API</strong> and the <strong>Cache</strong>.
In fact, the cache is itself a model middleware (added by default, unless disabled).</p>
</div>
<div class="paragraph">
<p>To implement a model middleware, use the <code>org.kodein.db.model.ModelDB</code> interface and the <code>org.kodein.db.Middleware.Model</code> container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">typealias ModelMiddleware = ((ModelDB) -&gt; ModelDB)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a very simple model middleware that counts how many models you&#8217;ve put inside the database:</p>
</div>
<div class="listingblock">
<div class="title">A put counter model middleware</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class PutCountModelDB(val base: ModelDB, val count: AtomicInt) : ModelDB by base { <i class="conum" data-value="1"></i><b>(1)</b>
    override fun &lt;M : Any&gt; put(key: Key&lt;M&gt;, model: M, vararg options: Options.Write): Int {
        val ret = base.put(key, model, *options)
        count.incrementAndGet() <i class="conum" data-value="2"></i><b>(2)</b>
        return ret
    }

    override fun &lt;M : Any&gt; put(model: M, vararg options: Options.Write): KeyAndSize&lt;M&gt; {
        val ret = base.put(model, *options)
        count.incrementAndGet() <i class="conum" data-value="2"></i><b>(2)</b>
        return ret
    }

    override fun newBatch(): ModelBatch = PutCountModelBatch(base.newBatch(), count)
}

class PutCountModelBatch(val base: ModelBatch, val count: AtomicInt) : ModelBatch by base { <i class="conum" data-value="1"></i><b>(1)</b>
    private var willAdd = 0 <i class="conum" data-value="3"></i><b>(3)</b>

    override fun &lt;M : Any&gt; put(key: Key&lt;M&gt;, model: M, vararg options: Options.Write): Int {
        val ret = base.put(key, model, *options)
        willAdd += 1 <i class="conum" data-value="2"></i><b>(2)</b>
        return ret
    }

    override fun &lt;M : Any&gt; put(model: M, vararg options: Options.Write): KeyAndSize&lt;M&gt; {
        val ret = base.put(model, *options)
        willAdd += 1 <i class="conum" data-value="2"></i><b>(2)</b>
        return ret
    }

    override fun write(afterErrors: MaybeThrowable, vararg options: Options.Write) {
        base.write(afterErrors, *options)
        repeat(willAdd) { count.incrementAndGet() } <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

fun putCountModelMiddleware(count: AtomicInt) =
        Middleware.Model { base -&gt; PutCountModelDB(base, count) } <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Delegates every non-overloaded methods to the underneath layer</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Increment <strong>after</strong> the put operation, because it may fail</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Actually report the put operations only once the batch has been writen</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The middleware itself, that encapsulates the ModelDB layer inside the decorator.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Counting count would be a lot easier with a simple <a href="#reaction">listener</a>.
      This is only a silly example!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to actually add the middleware to the database when opening it!</p>
</div>
<div class="listingblock">
<div class="title">Using LevelDB options:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val putCount = atomic(0)
val db = DB.open(
    "path/to/db",
    putCountModelMiddleware(putCount)
)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_data_middleware"><a class="anchor" href="#_data_middleware"></a>Data middleware</h4>
<div class="paragraph">
<p>A data middleware sits between the <strong>Data</strong> and the <strong>Model</strong> layers.
It works exactly like a model middleware, except that you manipulate <a href="#values-and-buffers">values and buffers</a> instead of models and objects.</p>
</div>
<div class="paragraph">
<p>To implement a data middleware, use the <code>org.kodein.db.data.DataDB</code> interface and the <code>org.kodein.db.Middleware.Data</code> container.</p>
</div>
</div>
<div class="sect3">
<h4 id="_leveldb_middleware"><a class="anchor" href="#_leveldb_middleware"></a>LevelDB middleware</h4>
<div class="paragraph">
<p>A LevelDB middleware sits between the <strong>LevelDB</strong> and the <strong>Data</strong> layers.
It works exactly like a data middleware, except that you manipulate raw data instead of documents, which means that a simple operation in Kodein-DB will probably lead to multiple operations at the LevelDB layer.</p>
</div>
<div class="paragraph">
<p>To implement a LevelDB middleware, use the <code>org.kodein.db.leveldb.LevelDB</code> interface and the <code>org.kodein.db.Middleware.Level</code> container.</p>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
<!--  <a class="navbar-item" href="https://kodein.net" target="_blank">-->
<!--    <div style="padding: 0.5rem;opacity:0.8;">by</div>-->
<!--    <div style="font-weight: 700;">KODEIN</div>-->
<!--    <div style="font-weight: 300;opacity:0.8;">Koders</div>-->
<!--  </a>-->
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
